### **Timeline.ts：進化版ライブラリ仕様書**

#### **1. 理念：完成された「全自動リソース管理」**

`timeline-for-ai`フレームワークの根底には、物理学の「ブロック宇宙」モデルに基づいた、時間と共に変化する値を宣言的に扱うという思想があります。その理想の核心は、開発者がリソースの生成や破棄のタイミングを一切気にすることなく、本質的なロジックの記述に集中できる **「全自動リソース管理」** の実現にありました。

これまでの議論を通じて、我々はこの理想を、リアクティブな内部状態だけでなく、Gnome Shell拡張のGTKウィジェットのような、**あらゆる外部リソースのライフサイクル**にまで適用する道筋を発見しました。

これから解説する新しい`DependencyCore`と`using`/`nUsing`プリミティブは、その理想を完全に具現化する、このフレームワークの**最終的な完成形**です。

-----

#### **2. `DependencyCore`：進化した心臓部 - 汎用的なライフサイクル基盤**

この進化版ライブラリのすべての能力は、心臓部である`DependencyCore`の、たった一つの、しかし根源的な機能拡張に支えられています。

##### **設計方針**

`DependencyCore`は、もはや単なる「リアクティブな接続」の管理システムではありません。それは、**「依存関係の生存期間（ライフサイクル）に紐づく、あらゆる種類のクリーンアップ処理」を保証する、汎用的な基盤**へと進化しました。

##### **能力と仕様**

  * **新機能：`onDispose`コールバック**

      * 依存関係を登録する`DependencyCore.registerDependency`は、新たに`onDispose?: () => void`というオプショナルな引数を受け取ります。
      * この`onDispose`関数は、その依存関係が**破棄される際に、実行が100%保証されるコールバック**です。

  * **実行保証のメカニズム**

      * 依存関係の破棄は、`DependencyCore.removeDependency`によって行われます。この関数は、依存関係を内部マップから削除する直前に、登録されていた`onDispose`関数を呼び出します。
      * `bind`や後述する`using`がスコープを管理するために呼び出す`DependencyCore.disposeScope`は、スコープに属するすべての依存関係に対して`removeDependency`を呼び出します。
      * これにより、スコープが破棄されると、それに紐づく**すべてのクリーンアップ処理が、連鎖的かつ確実に実行される**ことがフレームワークレベルで保証されます。

  * **汎用性と後方互換性**

      * この拡張は、**特定の用途に限定されません**。`onDispose`はオプショナルであり、指定されなければ何も起こりません。
      * したがって、既存の`map`や`bind`など、クリーンアップを必要としない全てのAPIは、この新しい基盤の上で**これまでと全く同じように、一切のオーバーヘッドなく動作します**。
      * これは、ライブラリの思想を分断する特殊機能ではなく、全体の堅牢性を底上げする、**普遍的かつ後方互換な進化**です。

-----

#### **3. `using` / `nUsing`：究極のリソース管理API**

この進化した`DependencyCore`の能力を、開発者が最もエレガントに、かつ安全に利用できるように設計された新しい標準プリミティブが`using`と`nUsing`です。これらは、**「リソースの生存期間」を「`Timeline`のスコープ」と完全に同期させる**ための、唯一の正しいアプローチです。

##### **`using` API仕様**

  * **目的**: あらゆる種類のリソース（UIウィジェット、ファイルハンドル、ネットワーク接続、タイマー等）の生成（Setup）と破棄（Teardown）を、宣言的に、かつ完全に自動化します。

  * **シグネチャ**:

    ```typescript
    using<B>(
        resourceFactory: (value: A) => { resource: B; cleanup: () => void } | null
    ): Timeline<B | null>
    ```

  * **動作と保証**:

    1.  `sourceTimeline`の値が変化すると、`using`はまず、**以前のスコープで生成されたリソースに紐づく`cleanup`関数を、`disposeScope`を通じて確実に実行します。**
    2.  次に、新しい値で`resourceFactory`関数を呼び出します。
    3.  `resourceFactory`が`{ resource, cleanup }`オブジェクトを返した場合：
          * `resource`が、出力`Timeline`の新しい値となります。
          * `cleanup`関数が、新しいスコープに紐づく`onDispose`コールバックとして`DependencyCore`に登録されます。
    4.  `resourceFactory`が`null`を返した場合、出力`Timeline`は`null`となり、クリーンアップ処理も登録されません。

    <!-- end list -->

      * **保証**: このメカニズムにより、`resourceFactory`によって一度でも生成されたリソースは、そのスコープが（どのような理由であれ）終了する際に、**対応する`cleanup`関数が必ず呼び出される**ことが保証されます。これにより、リソースリークは構造的に発生し得ません。

##### **`nUsing` API仕様**

  * **目的**: `using`の能力を、Gnome Shell拡張開発などで最も頻発する「`null`でない時だけリソースを生成する」という定型的なシナリオのために、さらに洗練させたものです。

  * **シグネチャ**:

    ```typescript
    nUsing<B>(
        resourceFactory: (value: A) => { resource: B; cleanup: () => void } | null
    ): Timeline<B | null>
    ```

    *注: `nUsing`を呼び出す`Timeline`の型`A`は`A | null`であることが期待されます。`resourceFactory`が受け取る`value`の型は、`null`でないことが保証された`A`となります。*

  * **動作と価値**:

      * `nUsing`は`using`の高レベルなラッパーです。
      * ソース`Timeline`の値が`null`または`undefined`の場合、`nUsing`は自動的に**以前のリソースを破棄し、出力`Timeline`を`null`にします**。開発者が提供する`resourceFactory`は呼び出されません。
      * これにより、開発者は成功ケースのロジック（`null`でない場合の処理）の記述にのみ集中でき、定型的な`null`チェックのコードは完全に不要になります。これは、コードの可読性を劇的に向上させ、バグの発生を未然に防ぎます。

##### **エッジケースへの有効性**

この設計は、我々が議論の過程で発見した**最も困難なエッジケース**（`scan`パターンでは解決できなかった問題）を完璧に解決します。

  * **問題**: `using`処理全体が、さらに上位の`bind`スコープによって、能動的な状態変化なしに破棄された場合、リソースはリークしないか？
  * **答え**: **リークしません。** `using`が生成したスコープと`cleanup`関数は、上位の`bind`が管理するスコープの子となります。上位の`bind`が`disposeScope`を呼び出すと、その効果は連鎖的に伝播し、`using`が登録した`onDispose`コールバックも**確実に実行されます**。これこそが、このアーキテクチャが持つ、真の堅牢性です。

-----

#### **4. 開発支援機能：デバッグとトラブルシューティング**

複雑なリソース管理とスコープ階層を持つこのフレームワークでは、実際の開発現場における**デバッグ効率**が極めて重要です。そのため、フレームワークには包括的なデバッグ支援機能が統合されています。

##### **デバッグ支援機能の設計**

  * **開発環境専用の実装**: デバッグ情報の収集と追跡は、開発環境でのみ有効化されます。これにより、**プロダクション環境では一切のオーバーヘッドが発生しません**。

  * **スコープ階層の可視化**:
      * 各スコープの作成時刻、親子関係、所属する依存関係の一覧を記録
      * `DebugUtils.printTree()`による依存関係ツリーの視覚的表示
      * スコープのライフサイクル全体の追跡とログ出力

  * **依存関係の詳細監視**:
      * 各依存関係の作成・破棄タイミングの記録
      * `onDispose`コールバックの実行状況の監視
      * リソースリークの早期発見と原因特定

##### **実用的な価値**

この統合されたデバッグ支援により、開発者は**複雑なリソース管理の問題を迅速に特定**できます。特に以下のような場面で威力を発揮します：

  * Gnome Shell拡張のような、システムレベルでの複雑なUIリソース管理
  * 長時間動作するアプリケーションでのメモリリーク診断
  * 入れ子になった`using`/`nUsing`パターンでの予期しない動作の解析

-----

#### **5. 総合的な価値と将来展望**

この`Timeline`は、もはや単なるFRPライブラリではありません。それは、宣言的なデータフローと、命令的なリソース管理という、しばしば対立するパラダイムを、 **「ライフサイクル」** という単一の統一された概念の下に完全に統合した、新しい次元のフレームワークです。

**デバッグ効率**と**プロダクション環境でのパフォーマンス**を両立させる設計により、このフレームワークは研究開発段階から実用段階まで、一貫して開発者を支援します。これは、理論的な美しさと実用的な価値を兼ね備えた、真に完成されたソフトウェアアーキテクチャの実現です。